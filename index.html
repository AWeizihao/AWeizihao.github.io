<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blog.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Freedom, Liberation, Persistence, Responsibility">
<meta property="og:type" content="website">
<meta property="og:title" content="Arcadia">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Arcadia">
<meta property="og:description" content="Freedom, Liberation, Persistence, Responsibility">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weizihao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Arcadia</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Arcadia</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Pegasus's wings, Prometheus's fire, Sisyphus' blouder, Atlas' shoulder</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-file fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weizihao">
      <meta itemprop="description" content="Freedom, Liberation, Persistence, Responsibility">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arcadia">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-16 21:49:23" itemprop="dateCreated datePublished" datetime="2023-07-16T21:49:23+08:00">2023-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-17 15:40:07" itemprop="dateModified" datetime="2023-07-17T15:40:07+08:00">2023-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h2><p>链表储存的数据在物理上是不连续的，各个数据之间由指针相连。链表的每个数据单元称为节点，链表的每一个节点储存两个指针和一个数据。第一个指针指向上一个节点，第二个指针指向下一个节点，数据则是该节点储存的内容。</p>
<p>如果省去第一个指针，就是一个<strong>单向链表</strong>，只能单向查询。</p>
<p>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。链表灵活，但是空间和时间额外耗费较大。</p>
<p>链表通常使用STL list实现，当然也可以手写链表。手写的链表根据内存是否动态分配，分为动态链表和静态链表。动态链表采用动态存储分配，不会造成内存浪费和溢出。</p>
<h3 id="1-1-静态链表"><a href="#1-1-静态链表" class="headerlink" title="1.1 静态链表"></a>1.1 静态链表</h3><p>我们当然可以使用二维数组实现链表，不过我们这里使用结构体定义链表。</p>
<h4 id="1-1-1-结构体简介"><a href="#1-1-1-结构体简介" class="headerlink" title="1.1.1 结构体简介"></a>1.1.1 结构体简介</h4><p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>允许用户存储不同类型的数据项。</p>
<p>假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：<br>Title ：标题<br>Author ：作者<br>Subject ：类目<br>Book ID ：书的 ID</p>
<ul>
<li><p><strong>定义结构体</strong><br>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;</span><br><span class="line">        member_type1 member_name1;</span><br><span class="line">        member_type2 member_name2;</span><br><span class="line">        member_type3 member_name3;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125; object_names;</span><br></pre></td></tr></table></figure>
<p>  type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。</p>
<p>  在结构定义的末尾，最后一个分号之前，您可以指定<strong>一个或多个结构变量</strong>，这是可选的相当于一个全局的变量定义，当然这个定义也可以放到其他地方。下面是声明一个结构体类型 Books，变量为 book（在全局定义变量book为Book类型）：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span>&#123;</span><br><span class="line">        <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">        <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">        <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span>   book_id;</span><br><span class="line">    &#125; book;</span><br></pre></td></tr></table></figure></li>
<li><strong>访问结构体成员</strong><br>如果要访问结构成员，需要用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。例如，对于上面的例子，我想知道一本书的book_id，就用下面的方法访问：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.book_id</span><br></pre></td></tr></table></figure>
这可以直接看作一个int类型的变量。例如输入bookid，就可以写成：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; book.book_id;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>结构体作为参数</strong><br>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span>&#123; <span class="comment">// 声明一个结构体类型 Books </span></span><br><span class="line">        <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">        <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">        <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span>   book_id;</span><br><span class="line">    &#125;book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> &lt;&lt; book.author &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-双向静态链表实现"><a href="#1-1-2-双向静态链表实现" class="headerlink" title="1.1.2 双向静态链表实现"></a>1.1.2 双向静态链表实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> id,pre,next; <span class="comment">//分别是此节点，上一个节点和下一个节点的下标</span></span><br><span class="line">&#125;nodes[N]<span class="comment">//定义在全局的静态分配。</span></span><br><span class="line"><span class="comment">//这里需要注意的是，大静态数组最好在全局定义，如果在函数内部定义可能出现爆栈，因为数组被储存在栈中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    nodes[<span class="number">0</span>].next=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n;i++)&#123;</span><br><span class="line">            nodes[i].id=i;</span><br><span class="line">            nodes[i].pre=i<span class="number">-1</span>;<span class="comment">//前节点</span></span><br><span class="line">            nodes[i].next=i+<span class="number">1</span>;<span class="comment">//后节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    nodes[n].next=<span class="number">1</span>;</span><br><span class="line">    nodes[<span class="number">0</span>].pre=n; <span class="comment">//首尾相接</span></span><br><span class="line">    <span class="comment">// 至此完成了一个双向链表的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-动态链表"><a href="#1-2-动态链表" class="headerlink" title="1.2 动态链表"></a>1.2 动态链表</h3><h4 id="1-2-1-箭头算符-gt"><a href="#1-2-1-箭头算符-gt" class="headerlink" title="1.2.1 箭头算符-&gt;"></a>1.2.1 箭头算符<code>-&gt;</code></h4><p>这也是一个成员访问算符，只不过，它要求左端必须是指向类或结构的指针，而右边则是结果或类的成员。例如下面这个结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span>&#123; </span><br><span class="line">        <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">        <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">        <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span>   book_id;</span><br><span class="line">    &#125;book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Books *p;</span><br><span class="line">    p-&gt;title=<span class="number">1</span>;<span class="comment">//赋值为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-2-动态链表实现"><a href="#1-2-2-动态链表实现" class="headerlink" title="1.2.2 动态链表实现"></a>1.2.2 动态链表实现</h4><h3 id="1-3-STL-list"><a href="#1-3-STL-list" class="headerlink" title="1.3 STL list"></a>1.3 STL list</h3><p>STL是Standard Template Library，标准模板库。 STL list是一个封装好的双向链表，相较于vector的连续线性空间，list的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。 List和vector是两个最常被使用的容器。 </p>
<ul>
<li><p><strong>list容器的创建</strong><br>根据不同的使用场景，有以下 5 种创建 list 容器的方式供选择。</p>
<ul>
<li><p>1 创建一个没有任何元素的空 list 容器：<br><code>std::list&lt;int&gt; values;</code><br>和空 array 容器不同，空的 list 容器在创建之后仍可以添加元素，因此创建 list 容器的方式很常用。</p>
</li>
<li><p>2 创建一个包含 n 个元素的 list 容器：<br><code>std::list&lt;int&gt; values(10);</code><br>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。</p>
</li>
<li><p>3 创建一个包含 n 个元素的 list 容器，并为每个元素指定初始值。例如：<br><code>std::list&lt;int&gt; values(10, 5);</code><br>如此就创建了一个包含 10 个元素并且值都为 5 的 values 容器。</p>
</li>
<li><p>4 在已有 list 容器的情况下，通过拷贝该容器可以创建新的 list 容器。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
</li>
<li><p>5 通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 list 容器。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝普通数组，创建list容器</span></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>; <span class="comment">//拷贝其它类型的容器，创建 list 容器</span></span><br><span class="line">std::array&lt;<span class="type">int</span>,5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(arr.begin()+<span class="number">2</span>, arr.end())</span></span>;<span class="comment">//拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>list容器的成员函数</strong><br>表 2 中罗列出了 list 模板类提供的所有成员函数以及各自的功能。</p>
</li>
</ul>
<pre><code>|成员函数    |功能|
|-------|--|
|**begin()**|返回指向容器中第一个元素的双向迭代器。|
|**end()**    |返回指向容器中最后一个元素所在位置的**下一个**位置的双向迭代器。
|**front()**    |返回第一个元素的引用。
|**back()**    |返回最后一个元素的引用。
|**push_front()**    |在容器头部插入一个元素。
|**pop_front()**    |删除容器头部的一个元素。
|**push_back()**    |在容器尾部插入一个元素。
|**pop_back()**    |删除容器尾部的一个元素。
|**sort()**    |通过更改容器中元素的位置，将它们进行排序。
|empty()    |判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。
|**size()**    |返回当前容器实际包含的元素个数。
|max_size()    |返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。
|**assign()**    |用新元素替换容器中原有内容。
|**insert()**     |在容器中的指定位置插入元素。
|**erase()**    |删除容器中一个或某区域内的元素。
|**swap()**    |交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。
|**clear()**    |删除容器存储的所有元素。
| **unique()**    |删除容器中相邻的重复元素，只保留一个。
|merge()    |合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。
|reverse()    |反转容器中元素的顺序。 
|rbegin()    |返回指向最后一个元素的反向双向迭代器。
|rend()    |返回指向第一个元素所在位置前一个位置的反向双向迭代器。
|cbegin()    |和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
|cend()    |和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
|crbegin()     |和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
|crend()    |和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
|emplace_front()    |在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。
|emplace_back()    |在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。
|emplace()    |在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。
|resize()    |调整容器的大小。
|splice()    |将一个 list 容器中的元素插入到另一个容器的指定位置。
|remove(val)    |删除容器中所有等于 val 的元素。
|remove_if()    |删除容器中满足条件的元素。
</code></pre><p>如下代码演示了表中部分成员函数的用法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    list&lt;<span class="type">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">3.1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.2</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2.9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">double</span>&gt;::iterator it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values size：3</span><br><span class="line">2.2 2.9 3.1</span><br></pre></td></tr></table></figure></p>
<h4 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h4><p>迭代器iterator是C++ STL的组件之一，作用是用来遍历容器，而且是<strong>通用的</strong>遍历容器元素的方式，无论容器是基于什么数据结构实现的，尽管不同的数据结构，遍历元素的方式不一样，但是用迭代器遍历不同容器的代码是完全一样的。</p>
<p>迭代器的定义非常简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1=vec1.<span class="built_in">begin</span>(); <span class="comment">//创建了vector容器的一个迭代器，初始化为容器的第一个元素的指针</span></span><br><span class="line">list&lt;<span class="type">double</span>&gt;::iterator it2=node.<span class="built_in">begin</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    ···<span class="comment">//注意结束条件是不等于，而不是小于，因为对于list这种容器，其储存是不连续的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/16/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weizihao">
      <meta itemprop="description" content="Freedom, Liberation, Persistence, Responsibility">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arcadia">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/16/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-07-16 10:17:01 / Modified: 14:37:45" itemprop="dateCreated datePublished" datetime="2023-07-16T10:17:01+08:00">2023-07-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-复杂度"><a href="#1-复杂度" class="headerlink" title="1  复杂度"></a>1  复杂度</h3><ul>
<li><p>算法的时间复杂度是指算法运行所需要的时间，空间复杂度则指算法占用的内存大小。<br>时间复杂度一般采用大O记法。</p>
<h4 id="1-时间的复杂度大O记法"><a href="#1-时间的复杂度大O记法" class="headerlink" title="1. 时间的复杂度大O记法"></a>1. 时间的复杂度大O记法</h4><p>对于一行代码，我们令其运行的时间的<strong>量级</strong>是1.故一循环n次的循环，运行时间就<strong>量级</strong>是n。假如存在循环嵌套，就记为$n^2$。</p>
<p>我们把这些时间加起来，汇成一个关于循环次数n的函数$f(n)$（假设所有循环都是n次）。显然对于一个简单的循环嵌套。$f(n)=n^2$。当然，假如这个程序还存在其他部分，也要把时间加起来。例如，我们最后得到一个程序的运行时间$f(n)=5n^3+2n^2+20$。</p>
<p>这个时候，我们遵循下面的改写规则：</p>
<ul>
<li><strong>只记最高次项</strong></li>
<li><strong>不计系数</strong></li>
</ul>
<p>于是有:<script type="math/tex">f(n)\sim n^3</script>此时，可以改用大$O$记法，即记这个算法的时间复杂度为$O(n^3)$<br>下面介绍一些常见的时间复杂度。</p>
<h5 id="1-1-常数阶复杂度-O-1"><a href="#1-1-常数阶复杂度-O-1" class="headerlink" title="1.1 常数阶复杂度$O(1)$"></a>1.1 常数阶复杂度$O(1)$</h5><p>如果所有代码都只执行一遍，那么其运行时间就是每行代码时间相加，所以$f(n)=C$。但是在等价时，无论C如何取值，我们一律记作$O(1)$。<br>例如，下面的代码就是$O(1)$复杂度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_a_number</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> inn;</span><br><span class="line">  inn=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">if</span>(inn&gt;=<span class="string">&quot;0&quot;</span>&amp;&amp;inn&lt;=<span class="string">&quot;9&quot;</span>)   a=inn-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常数阶代码中不包含循环。</p>
<h5 id="1-2-线性阶复杂度-O-n"><a href="#1-2-线性阶复杂度-O-n" class="headerlink" title="1.2 线性阶复杂度$O(n)$"></a>1.2 线性阶复杂度$O(n)$</h5><p>这是程序中存在（无嵌套的）循环的情况。</p>
<h5 id="1-3-对数阶复杂度-O-text-log-n"><a href="#1-3-对数阶复杂度-O-text-log-n" class="headerlink" title="1.3 对数阶复杂度$O(\text{log}n)$"></a>1.3 对数阶复杂度$O(\text{log}n)$</h5><p>这是当循环变量以指数速度增长时的复杂度，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 执行一次</span></span><br><span class="line">  <span class="keyword">while</span> (count &lt;= n) &#123; <span class="comment">// 执行logn次</span></span><br><span class="line">      count = count*<span class="number">2</span>; <span class="comment">// 执行logn次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4线性对数阶-O-n-text-log-n"><a href="#1-4线性对数阶-O-n-text-log-n" class="headerlink" title="1.4线性对数阶$O(n\text{log}n)$"></a>1.4线性对数阶$O(n\text{log}n)$</h5><p>这也即是把对数阶的代码循环n次。</p>
<h5 id="1-5-平方阶-O-n-2"><a href="#1-5-平方阶-O-n-2" class="headerlink" title="1.5 平方阶$O(n^2)$"></a>1.5 平方阶$O(n^2)$</h5><p>这是用于循环嵌套的程序。如果两次循环次数不一样，那么就可以表示为$O(m*n)$</p>
</li>
</ul>
<h3 id="2-前缀和"><a href="#2-前缀和" class="headerlink" title="2. 前缀和"></a>2. 前缀和</h3><p>前缀和，顾名思义，就是一个数组的前n项之和。给定一个数组arr[0…n-1]，我们定义一个新的数组prefix_sum[0…n]，其中prefix_sum[i]表示arr[0]到arr[i]的和，即</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix_sum[i] = arr[<span class="number">0</span>] + arr[<span class="number">1</span>] + ... + arr[i-<span class="number">1</span>] + arr[i]</span><br></pre></td></tr></table></figure>
<p>prefix_sum[0]没有什么意义。</p>
<h4 id="2-1-应用"><a href="#2-1-应用" class="headerlink" title="2.1 应用"></a>2.1 应用</h4><p>前缀和的意义是什么？前缀和可以帮助我们<strong>快速计算和查询一子数组的和</strong>。</p>
<p>给定一个数组，我们可能需要多次查询某个范围内元素的和，例如arr[i]到arr[j]的和。如果我们每次查询都重新计算这个和，那么每次查询的时间复杂度将是O(n)，这在查询次数大的情况下会非常低效。</p>
<p>使用前缀和，我们可以在O(1)的时间复杂度内查询任何子数组的和。这是因为，arr[i]到arr[j]的和可以通过前缀和计算出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum_i_to_j = prefix_sum[j] - prefix_sum[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h4><p>假设有一个数组arr = [1, 2, 3, 4, 5]，我们想要查询子数组arr[1…3]的和。</p>
<p>首先，我们计算前缀和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">prefix_sum=[]</span><br><span class="line">tmp=arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">    prefix_sum.append(tmp)</span><br><span class="line">    tmp=tmp+i</span><br><span class="line"><span class="built_in">print</span>(prefix_sum)  <span class="comment"># 输出: [0, 1, 3, 6, 10, 15]</span></span><br></pre></td></tr></table></figure>
<p>然后，我们可以使用前缀和查询子数组的和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">3</span></span><br><span class="line">sum_i_to_j = prefix_sum[j] - prefix_sum[i-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(sum_i_j)  <span class="comment"># 输出: 9</span></span><br></pre></td></tr></table></figure>
<h3 id="3-差分"><a href="#3-差分" class="headerlink" title="3.差分"></a>3.差分</h3><p>差分可以视为与前缀和互逆。假如数列<code>a=[a1,a2,a3,...,an]</code>，而<code>b=[b1,b2,b3,...,bn]</code>。如果，a是b的前缀和数列，即<code>ai=b1+b2+...+bi</code>，那么就称b是a的<strong>差分数列</strong>，也就是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bi=ai-<span class="built_in">a</span>(i<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="3-1-区间修改"><a href="#3-1-区间修改" class="headerlink" title="3.1 区间修改"></a>3.1 区间修改</h5><p>先要把[L,R]区间上的a数组全部加上数C。如果直接死算，时间复杂度会有O(n)，但是使用差分，复杂度只有O(1).</p>
<p>差分的基本方法是由b数组计算a数组。由于关系式<code>ai=b1+b2+...+bi</code>，如果我们对b[L]这一项加上C，那么也就相应地使得i&gt;=L的所有ai都加上了C。但是因为存在上界，所以对i&gt;R的部分ai，我们希望保持原样，所以对b[R+1]减去C。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_C</span><span class="params">(<span class="type">int</span> C,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    a[<span class="number">0</span>]=b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+b[i];<span class="comment">//构造前缀和数组a</span></span><br><span class="line">    &#125;</span><br><span class="line">    b[L]+=C;</span><br><span class="line">    b[R+<span class="number">1</span>]-=C;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/17/Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weizihao">
      <meta itemprop="description" content="Freedom, Liberation, Persistence, Responsibility">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arcadia">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/Introduction/" class="post-title-link" itemprop="url">Introduction</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-17 15:42:22 / Modified: 15:58:52" itemprop="dateCreated datePublished" datetime="2023-06-17T15:42:22+08:00">2023-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>你好，陌生人，欢迎来到<strong>Arcadia</strong>！<br><strong>Arcadia</strong>是希腊神话中的一片花园，有世外桃源之意。<br>我希望Arcadia成为我发布和储存note的地方，包括计算机、物理等等学科的note，都会被发布在这里。我希望在储存和编译markdown语言的note方面，Arcadia能完全代替知乎。<br>您可以查看我的全部笔记，如果您愿意的话，您也可以在这里发布您的page。<br>Life sucks. 这些笔记若能解决您一个微不足道的困惑，我就感到非常满足了。Good Luck！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/17/%E5%8A%9B%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weizihao">
      <meta itemprop="description" content="Freedom, Liberation, Persistence, Responsibility">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arcadia">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/%E5%8A%9B%E5%AD%A6/" class="post-title-link" itemprop="url">力学（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-17 15:42:22 / Modified: 17:18:25" itemprop="dateCreated datePublished" datetime="2023-06-17T15:42:22+08:00">2023-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-质点运动学"><a href="#1-质点运动学" class="headerlink" title="1 质点运动学"></a>1 质点运动学</h2><h3 id="1-1-质点运动学方程"><a href="#1-1-质点运动学方程" class="headerlink" title="1.1 质点运动学方程"></a>1.1 质点运动学方程</h3><ul>
<li>1.1.1 质点相对于参考点的位置用<strong>位矢</strong>来描述。位置矢量在直角坐标系下分解为$\vec{r}=x\bm{i}+y\bm{j}+z\bm{k} $，其中$\bm{i}$、$\bm{j}$、$\bm{k}$分别为<em>xyz</em>三个方向的单位矢量。</li>
<li>1.1.2 <strong>质点的运动学方程</strong>指位置函数对时间t的函数 $\bm{r}=\bm{r}(t)$。在直角坐标系下可以分解为$\vec{r}=x(t)\bm{i}+y(t)\bm{j}+z(t)\bm{k} $.<br>而标量方程组{ $x(t), y(t), z(t)$ }则是<strong>运动学方程的标量形式</strong>。</li>
<li>1.1.3 <strong>轨迹方程</strong>是 $y=y(x)$ 或者 $f(x,y,z)=0$ 的形式，经过运动学方程的标量形式联立消去时间t得到。</li>
<li>1.1.4 <strong>位移</strong>是位置矢量的增量，从质点的初位置指向末位置，记作$\Delta \bm{r}$。按照定义$\Delta \bm{r}=\bm{r}(t+\Delta t)-\bm{r}(t)$.<br>&nbsp;<h3 id="1-2-速度和加速度"><a href="#1-2-速度和加速度" class="headerlink" title="1.2 速度和加速度"></a>1.2 速度和加速度</h3></li>
<li>1.2.1 速度 $\bm{v}=\lim_{\Delta t \to 0} \frac{\Delta \bm{r} }{\Delta t}=\frac{d\bm{r} }{dt}$.</li>
<li>1.2.2 瞬时速度的方向沿轨迹的切线方向，大小$v=|\bm{v}|=\lim_{\Delta t \to 0} \frac{|\Delta \bm{r}|}{\Delta t}=|\frac{d\bm{r} }{dt}|$，也就是瞬时速率。</li>
<li>1.2.3 速率需要区别于 $\frac{dr}{dt} $和 $\frac{ds}{dt}$。<br>$\frac{dr}{dt}$ 是标量函数 $r(t)$对时间的导数，即位矢$\bm{r}(t)$的长度的变化率。<br>而$\frac{ds}{dt}$的意思是路程对时间的变化率。<br>另，$\frac{|d\bm{r}|}{dt}$即$|\bm{r}|=\sqrt{x^2+y^2+z^2}$对时间t的导数，啥也不是。</li>
<li>1.2.4 速度的分量$\bm{v}=\frac{d\bm{r} }{dt}=\frac{dx}{dt}\bm{i}+\frac{dy}{dt}\bm{j}+\frac{dz}{dt}\bm{k}$,于是可以得到速度的三个分量。</li>
<li>1.2.5 <strong>加速度</strong>$ \bm{a}=\lim_{\Delta t \to 0} \frac{\Delta \bm{v} }{\Delta t}=\frac{d\bm{v} }{dt}=\frac{d^2\bm{r} }{dt^2}$.</li>
<li>1.2.6 与速度同理，加速度也可以分解，$\bm{a}=\frac{d\bm{v} }{dt}=\frac{dv_x}{dt}\bm{i}+\frac{dv_y}{dt}\bm{j}+\frac{dv_z}{dt}\bm{k}$.</li>
<li>1.2.7 由$\bm{a}=\frac{d\bm{v} }{dt}=\frac{d^2\bm{r} }{dt^2}$可得，$\bm{r}=\int\bm{v}\, {\rm d}t=\int (\int\bm{a}\, {\rm d}t)\, {\rm d}t$.根据牛顿莱布尼兹公式，只要给定了初始条件，r、v、a任意知道其一就可以求出其他两个，也就意味着物体整个运动学方程就被唯一确定。<br>&nbsp;<h3 id="1-3-坐标系"><a href="#1-3-坐标系" class="headerlink" title="1.3 坐标系"></a>1.3 坐标系</h3></li>
<li>1.3.1 <strong>直角坐标系</strong><br>上面的内容全部在直角坐标系下进行。</li>
<li><p>1.3.1.1 例：抛体运动，一物体在原点被斜向上抛出，速度$v$与x轴夹角为$\alpha$，求其轨迹方程和运动学方程。<br>解：写出斜抛的x和y分量对t的方程，<script type="math/tex">x=v_0cos\alpha·t</script> <script type="math/tex">y=v_0sin\alpha·t-\frac{1}{2}gt^2</script> 联立，消去t，得到<strong>轨迹方程</strong><script type="math/tex">y=xtan\alpha-\frac{gx^2}{2v_0^2cos^2\alpha}</script><strong>运动学方程</strong>则为<script type="math/tex">\bm{r}=x\bm{i}+y\bm{j}=(v_0cos\alpha·t)\bm{i}+(v_0sin\alpha·t-\frac{1}{2}gt^2)\bm{j}</script>也可以从矢量考虑，抛体运动可以分为垂直的下落和水平的匀速运动，所以<script type="math/tex">\bm{r}=\bm{r_1}+\bm{r_2}=\bm{v_0}t+\frac{1}{2}\bm{g}t^2</script>写成分量形式结果是一样的（注意g与j的方向相反，应该取负数）。</p>
</li>
<li><p>1.3.2 <strong>自然坐标系</strong><br>如果物体运动轨迹确定，那么物体运动只剩下了一个<strong>自由度</strong>。这时可以用轨迹曲线的长度作为质点位置的度量，即$s=s(t)$，这就是自然坐标系。</p>
<ul>
<li>1.3.2.1 <strong>速度</strong>：那么自然坐标系下的速度就是$v=\frac{ds}{dt}$，s是曲线的长度，所以这样得到的速度其实是切向的（但也是唯一的速度，因为轨迹确定以后速度一定沿着切线方向）。</li>
<li>1.3.2.2 <strong>加速度</strong>：加速度是允许有法向分量的，这个分量让速度转向。所以把加速度写成矢量叠加的形式$\bm{a}=a_t\bm{e_t}+a_n\bm{e_n}$。<br>这里$a_t$是<strong>切向加速度</strong>（$\bm{e_t}$是切向单位矢量），这个加速度只改变速度大小。所以$a_t=\frac{dv}{dt}$.<br>而$a_n$是<strong>法向加速度</strong>（$\bm{e_n}$是法向单位矢量），这个加速度只改变速度方向，因为它和速度垂直。<script type="math/tex; mode=display">\bm{a}=\frac{d\bm{v} }{dt}=\frac{d(\frac{ds}{dt}\bm{e_t})}{dt}$$ $$=\frac{d^2s}{dt}\bm{e_t}+\frac{d\bm{e_t} }{dt}\frac{ds}{dt}$$ $$=\frac{dv}{dt}\bm{e_t}+\frac{d\theta·\bm{e_n} }{dt}·v$$ $$=\frac{dv}{dt}\bm{e_t}+\frac{d\theta}{dt}v\bm{e_n}$$ $$=\frac{dv}{dt}\bm{e_t}+\omega v\bm{e_n}</script></li>
</ul>
<p>所以法向加速度为$a_n=\omega v=\frac{v^2}{\rho}$ 其中$\rho$是曲率半径。</p>
<ul>
<li>1.3.2.3 矢量化<br>其实上面对自然坐标系加速度的推导已经用到了矢量工具了，下面将矢量方法引入角度。<br>我们先考虑圆周运动情况。<br>圆周运动中无限小转角$d\theta$通常叫做无限小角位移，它是一个标量。但是现在引入<strong>角位移矢量</strong>，$d\bm{\theta}=d\theta\bm{k}$，方向指向右手螺旋定则确定的z正方向（与角位移平面垂直）。<br>于是角速度和角加速度可以写成<script type="math/tex">\bm{\omega}=\frac{d\bm{\theta} }{dt}=\frac{d\theta}{dt}\bm{k}=\omega\bm{k}$$$$\bm{\beta}=\frac{d\bm{\theta} }{dt}=\frac{d\theta}{dt}\bm{k}+\bm{\omega}\frac{d\bm{k} }{dt}=\beta \bm{k}</script>考虑到$\bm{k}$是一个常矢量，所以上式第二项为0.<br>圆周运动下的无限小位移$d\bm{r}$和角位移矢量obviously存在下面的关系：<script type="math/tex">d\bm{r}=d\bm{\theta}\times\bm{r}</script>这里$\bm{r}$的起点选取为圆心。<br>所以质点速度即是<script type="math/tex">\bm{v}=\frac{d\bm{r} }{dt}=\frac{d\bm{\theta}\times \bm{r} }{dt}=\bm{\omega}\times\bm{r}</script>加速度即是<script type="math/tex">\bm{a}=\frac{d\bm{v} }{dt}=\frac{d\bm{\omega} }{dt}\times\bm{r}+\bm{\omega}\times\frac{d\bm{r} }{dt}=\bm{\beta}\times\bm{r}+\bm{\omega\times v}</script>可见加速度由两部分组成，$\bm{\beta}\times\bm{r}$是切向加速度，$\bm{\omega\times v}$是法向加速度，也就是向心加速度。<br>而对于一般的曲线运动，在每个无穷小位移上都可以看作是圆周运动，只是这时的半径要用轨迹方程的曲率半径代替：<script type="math/tex">\rho=\frac{(1+y'^2)^{3/2} }{|y''|}</script></li>
<li>1.3.2.3 如果物体做曲线运动（在每个无穷小位移上可以看成圆周运动），用自然坐标系会更简单。本质其实就是向心加速度和线加速度的矢量求和。自然坐标系分解也可以用于反向求曲线的曲率半径。<br>&nbsp;<h3 id="1-4-伽利略变换"><a href="#1-4-伽利略变换" class="headerlink" title="1.4 伽利略变换"></a>1.4 伽利略变换</h3></li>
</ul>
</li>
<li><p>1.4.1 相对于原参考系平动的参考系与原参考系满足伽利略变换关系。</p>
<script type="math/tex; mode=display">\begin{cases}
t=t'\\
\bm{r}=\bm{r'}+\Delta\bm{r}\\
\bm{v}=\bm{v'}+\Delta\bm{v}\\
\bm{a}=\bm{a'}
\end{cases}</script></li>
<li><p>1.4.2 <strong>位移</strong><br>$\bm{\Delta r}=\bm{u}t$，这里的u是运动参考系$O’x’y’z’$相对于基本参考系$Oxyz$的速度，所以$\bm{\Delta r}$从基本参考系$O$系（的原点）指向运动参考系$O’$系（的原点）。<br>而$\bm{r}$则是运动参考系$O’x’y’z’$里的一点在基本参考系$Oxyz$里的位置矢量，$\bm{r’}$则是那一点在运动参考系里的位矢。所以有$\bm{r}=\bm{r’}+\Delta\bm{r}$.</p>
</li>
<li>1.4.3 <strong>速度</strong><br>伽利略变换下的速度和位移是同理的，设在基本参考系里测得的速度为$\bm{v<em>{绝对} }$,在运动参考系里的速度为$\bm{v</em>{运动} }$，两个参考系之间的相对速度为$\bm{v<em>{牵连} }$，那么有$$\bm{v</em>{绝对} }=\bm{v<em>{运动} }+\bm{v</em>{牵连} }$$ </li>
<li>1.4.4 <strong>加速度</strong><br>值得注意的是，加速度在参考系变换时守恒： $\bm{a}=\bm{a’}$，这时因为相对速度恒定。伽利略变换只适用于惯性参考系，对于相对运动速度变化的参考系不适用。<br>&nbsp;<h3 id="1-5-牛顿运动定律和动量"><a href="#1-5-牛顿运动定律和动量" class="headerlink" title="1.5 牛顿运动定律和动量"></a>1.5 牛顿运动定律和动量</h3></li>
<li>1.5.1 <strong>牛顿第一定律</strong>指出，<strong>孤立质点静止或做匀速直线运动</strong>。这样的运动称作惯性运动。<br>　　然而，运动和静止都需要参考系作为前提，牛顿《原理》中的“静止”和“匀速直线运动”等概念，都是基于地球位于宇宙中心静止不动的观念，把地球作为一个静止的参考系。然而实际上地球因为公转和自转甚至是一个非惯性系。1885年一位德国物理学家提出惯性参考系，即<strong>孤立粒子是相对于惯性参考系静止或做匀速直线运动的，或者说，相对孤立粒子静止或做匀速直线运动的参考系为惯性参考系。</strong><br>　　而由于伽利略变换，相对于惯性参考系静止或匀速直线运动的参考系也是惯性参考系。<br>　　<strong>在所有惯性系中，力学定律具有相同的表述形式</strong>，这是经典力学相对性原理，也是由伽利略变换决定的。<br>　　但是，实际上并无真正的孤立粒子，也没有真正的惯性系。地球只是在很高的精度下可以作为惯性系处理，而人造卫星的问题通常把地心作为惯性系，行星运动则通常以太阳为惯性参考系。</li>
<li>1.5.2 <strong>牛顿第二定律</strong><ul>
<li>1.5.2.1 <strong>惯性质量</strong><br>马赫在《力学科学》中给出惯性质量的定义为，物体与标准物体碰撞，两物体速度差的倒数就是这个物体的惯性质量：$m=m_0|\Delta \bm{v_0}|/|\Delta \bm{v}|=|\Delta \bm{v_0}|/|\Delta \bm{v}| kg$。这被称为“质量的操作型定义”，这是利用动量守恒原理给出质量的定义。<br>而现代惯性质量的大小一般用物质的量说明。惯性质量表征物体的惯性大小，是用于定量描述惯性的，惯性质量越大，则惯性越大。</li>
<li>1.5.2.2 <strong>牛顿运动定律</strong><br>牛顿运动定律表述为<script type="math/tex">\sum\bm{F_i}=\frac{d\bm{p} }{dt}</script> F被定义为力，即一个物体对另一个物体的作用。又由于经典力学下质量不变，等式右边可以简化为$m\bm{a}$.</li>
</ul>
</li>
<li><p>1.5.3 <strong>牛顿第三定律</strong> 即力的作用是相互的。作用力的反作用力产生的时间差极小，一般可以认为同时产生。</p>
</li>
<li><p>1.5.4 <strong>非惯性系动力学</strong></p>
<ul>
<li>1.5.4.1 <strong>平移惯性力</strong><br>牛顿第二定律只适用于惯性系，要保持其形式在非惯性系里不变，可以引入惯性力，作为合外力的一部分。<br>设运动参考系$S’$相对于基本参考系$S$直线加速，加速度为$\bm{a<em>相}$（不一定为常矢量）。有一物体$m$相对于$S$系的加速度为$\bm{a_0}$（不一定为常矢量），那么根据牛顿第二定律判定物体受到真实力<script type="math/tex">\bm{F}=m\bm{a_0}</script> 物体$m$相对$S’$系的加速度为$$\bm{a’}=-\bm{a</em>相}+\bm{a<em>0}<script type="math/tex">得</script>m\bm{a’}=-m\bm{a</em>相}+m\bm{a<em>0}<script type="math/tex">也就是</script>m\bm{a’}=\bm{F}+(-m\bm{a</em>相})<script type="math/tex">在牛顿力学体系下进行的一切观察活动都必须认可由牛顿第二定律判定的真实力$\bm{F}$的存在。$S'$系在这一前提下，就要引入**平移惯性力** $ \bm{F^*}=-m\bm{a_相}$，现在我们得到</script>m\bm{a’}=\bm{F}+\bm{F^<em>}$$ 所以根据牛顿第二定律，等式右边的$\bm{F}+\bm{F^</em>}$就是在$S’$系里的“合外力”。<br>$S’$系的平动分两种，第一种是直线运动，第二种是曲线运动。对于第一种，如果$\bm{a_相}$恒定，那么惯性力$\bm{F^*}$也是恒力，与重力类似，有时可以与重力合成为等效重力。而第二种，例如摩天轮、行星转动，如果是匀速圆周运动，那么也视为是平移惯性力。<br>参看舒幼生《力学》p54 例6、7、8<ul>
<li><strong>二体约化质量</strong>：质量分别为$m_A$和$m_B$的质点$A$和$B$，其间作用力和反作用力分别为$\bm{F_A}$和$\bm{F_B}$.无外力，试求$A$相对于$B$的动力学方程。<br>任取惯性系S，B相对于S系的加速度为<script type="math/tex">\bm{a_B}=\frac{\bm{F_B} }{m_B}</script>再取一个随B运动的非惯性系S’，在S’中B是静止的，而A在S’里的加速度则为<script type="math/tex">\bm{a_A'}=-\bm{a_B}+\frac{\bm{F_A} }{m_A}</script>而由于$-\bm{F_A}=\bm{F_B}$，所以带入可以得到<script type="math/tex">\bm{a_A'}=\frac{\bm{F_A} }{m_B}+\frac{\bm{F_A} }{m_A}=\frac{m_A+m_B}{m_A m_B}\bm{F_A}</script> 定义<strong>二体约化质量</strong>$\mu=\frac{m_A m_B}{m_A+m_B}$，就可以得到一个简洁的牛顿第二定律形式<script type="math/tex">\bm{F_A}=\mu\bm{a_A'}</script>现在也可以直接写出$B$相对于A的动力学方程，那就是<script type="math/tex">\bm{F_B}=\mu\bm{a_B'}</script><br>二体约化质量可以方便地求解无外力的二体问题，对于只有一对相互作用力的两个孤立质点来说，一个质点相对于另一个质点的运动（其实就是假设另一个质点不动的参考系），可以直接利用所受的力和二体约化质量得到相对加速度。</li>
</ul>
<ul>
<li>1.5.4.2 <strong>惯性离心力</strong><br>惯性离心力数值上等于要维持当前速度和半径（曲率半径）进行匀速圆周运动所需要的向心力。<br>设有一个圆盘绕着中心轴匀速转动，空间上有一个惯性系$S$，转轴在惯性系$S$中静止。有一个物体$m$，放在圆盘上和圆盘一起转动。现建立一个相对物体$m$静止的非惯性系$S’$，也就是$S’$相对于$S$转动。<br>在$S$中考察，摩擦力为$m$提供向心力，<script type="math/tex">\bm{F}=-mw^2\bm{R}</script>但是在$S’$中考察，物体是静止的。然而在$S’$中，我们仍然要承认真实力的存在，所以引入虚拟力————惯性离心力 $\bm{F^<em>}=mw^2\bm{R} $，使得$$\bm{F}+\bm{F^</em>}=0$$</li>
<li>1.5.4.3 <strong>科里奥利力</strong><br>匀速旋转的非惯性系需要引入两类惯性力，第一类是离心力，第二类就是科氏力。如果物体$m$和$S’$相对静止，那么其实不存在科里奥利力。但是两者一旦有相对运动，就需要引入科里奥利力。<br>设物体$m$相对惯性系$S$静止，有非惯性系$S’$绕$S$转动，则物体在$S’$里反方向转动。这样一来，在$S’$里考察，物体转动需要一份向心力$\bm{F}=-m\omega^2\bm{R}$，而参考系$S’$旋转又会产生一份离心力$\bm{F}=m\omega^2\bm{R}$，因而一共需要虚拟力$\bm{F^*}=-2m\omega^2\bm{R}$来保持它在$S’$里的运动。这个虚拟力就是科里奥利力。<br>事实上，科里奥利力在右手系中的一般形式为<script type="math/tex">\bm{F_{Cor} }=2m\bm{v}\times\bm{\omega}</script>其中，$v$是物体相对$S’$的速度，大小为$\omega{R}$</li>
<li>1.5.4.4 惯性力的严格导出<br>略</li>
<li>1.5.4.5 惯性的本质<br>略<h2 id="2-动量和能量"><a href="#2-动量和能量" class="headerlink" title="2 动量和能量"></a>2 动量和能量</h2><h3 id="2-1-动量定理"><a href="#2-1-动量定理" class="headerlink" title="2.1 动量定理"></a>2.1 <strong>动量定理</strong></h3>对质点的力在时间上的积累称为<strong>冲量</strong>，冲量导致质点的动量发生改变。<br>质量为$m$的质点，在某惯性系的速度为$\bm{v}$，相对此惯性系的动量动量定义为<script type="math/tex">\bm{p}=m\bm{v}</script>质点所受力$\bm{F}$，经过$\mathrm{d}t$时间提供的冲量定义为<script type="math/tex">\mathrm{d}\bm{I}=\bm{F}\mathrm{d}t</script>于是在一段时间内的冲量便是对等式两边做积分<script type="math/tex">\bm{I}=\int{\bm{F} }\,{\rm d}t=\int{}\bm{ {\rm d}p}=\Delta\bm{p}</script>这就是质点动量定理：合力为质点提供的冲量等于质点动量的增量。<br>质点系的动量定理就是对动量、冲量等进行求和运算：<script type="math/tex">\bm{I}=\int{(\sum\bm{F})}\,{\rm d}t=\int{}\bm{ {\rm d}p}=\Delta\bm{p}</script>这里的动量$\bm{p}$是指整个质点系的动量，等于每个质点的动量的矢量和，也就是$\bm{p}=\sum\bm{p_i}$。而且由于$\sum\bm{F}$中的内力部分由于牛顿第三定律相互抵消，所以只需要考虑外力的作用。<br>于是质点系的动量定理表述为：质点系所受外力的矢量和在一段时间内的冲量（或外力冲量的和），等于质点系在这段时间内动量的增量。<br>当然，在非惯性系中，“外力”需要包括惯性力。<h3 id="2-2-动量守恒定律"><a href="#2-2-动量守恒定律" class="headerlink" title="2.2 动量守恒定律"></a>2.2 <strong>动量守恒定律</strong></h3>由动量定理，<strong>当惯性系下合外力为0时，质点（质点系）的动量守恒</strong>。<br>又由于力和动量都是矢量，于是<strong>动量守恒也在每个分量上单独成立</strong>。例如，对于直角坐标系而言，若$F_x$为$0$，则$p_x$是一个守恒量。其他两个方向同理。<br>动量守恒从牛顿三大定律的基础上推导而来，却比牛顿三大定律有更广泛的适用范围。迄今为止，动量守恒定律无论在物理学的哪个领域，都还没有失效过。<h3 id="2-3-质心运动定理"><a href="#2-3-质心运动定理" class="headerlink" title="2.3 质心运动定理"></a>2.3 <strong>质心运动定理</strong></h3>从质点系的动量定理，<script type="math/tex">\sum\bm{F_i}=\frac{ {\rm d}(\bm{\sum{I} })}{ {\rm d}t}=\frac{\sum{\rm d}\bm{ {I} } }{ {\rm d}t}=\frac{\sum{\rm d}\bm{p} }{ {\rm d}t}=\frac{ {\rm d}(\bm{\sum{p} })}{ {\rm d}t}=\frac{ {\rm d}(\sum m_i\bm{ {v_i} })}{ {\rm d}t}=\frac{ {\rm d^2}(\sum m_i\bm{ {r_i} })}{ {\rm d}t^2}</script> 用$m$表示质点系的总质量，就可以把上式写成<script type="math/tex">\sum\bm{F_i}=m\frac{ {\rm d^2} }{ {\rm d}t^2}(\frac{\sum m_i\bm{ {r_i} } }{m})</script>定义$\frac{\sum m_i\bm{ {r_i} } }{m}$为质点系的质心，即质心<script type="math/tex">\bm{r_c}=\frac{\sum m_i\bm{ {r_i} } }{m}</script>那么上式可以写成<script type="math/tex">\sum\bm{F_i}=m\bm
{a_c}</script>其中，$\bm{a_c}$被定义为质心的加速度。质心加速度由$\bm{a_c}=\frac{ {\rm d^2}\bm{r_c} }{ {\rm d}t^2}$给出。这就是质心运动定理。而且同样地，内力不会影响质点系，所以只需要考虑外力的作用。<br>质心的概念在刚体的章节还会详细讲述。<h3 id="2-4-变质量物体平动"><a href="#2-4-变质量物体平动" class="headerlink" title="2.4 变质量物体平动"></a>2.4 <strong>变质量物体平动</strong></h3></li>
</ul>
</li>
<li>2.4.1 <strong>质量增加</strong><br>$t$时刻主体质量$m$，速度$\bm{v}$，受力$\bm{F}$。增加的质量为$dm$,速度为$\bm{v’}$，受力$d\bm{F}$.<br>那么根据质点系动量定理有，<script type="math/tex">(\bm{F}+d\bm{F})dt=\Delta \bm{p}=(m+dm)(\bm{v}+d\bm{v})-(m\bm{v}+dm·\bm{v'})</script>略去高阶小量，得到<script type="math/tex">\bm{F}=m\frac{d\bm{v} }{dt}+(\bm{v}-\bm{v'})\frac{dm}{dt}</script>如果有$\bm{v’}=0$，那么就可以简化为<script type="math/tex">\bm{F}=m\frac{d\bm{v} }{dt}+\bm{v}\frac{dm}{dt}=\frac{d(m\bm{v})}{dt}</script><br>这样就得到了与牛顿第二定律相同的形式，但是本质上不一样，因为牛顿第二定律的质量是不变的。</li>
<li>2.4.2 <strong>质量减少</strong><br>质量减少如果只是把一部分质点从质点系里剥离（没有速度变化），那么和质量增加最后的公式是一致的。<br>如果要考虑分离速度，设减少的质量$dm&lt;0$，与主体分离的质量$dm$的速度为$v’$，则<script type="math/tex">\bm{F}dt=\Delta \bm{p}=[(m+dm)(\bm{v}+d\bm{v})+(-\bm{v'}dm)]-m\bm{v}</script>略去高阶小项，同样得到<script type="math/tex">\bm{F}=m\frac{d\bm{v} }{dt}+(\bm{v}-\bm{v'})\frac{dm}{dt}</script>如果引入分离速度<script type="math/tex">\bm{u}=\bm{v}-\bm{v'}</script>则可以把前式简化为<script type="math/tex">\bm{F}=m\frac{d\bm{v} }{dt}+\bm{u}\frac{dm}{dt}</script>例如火箭就是一个典型的质量减少的平动问题。此时的$\bm{u}$就是喷出火焰的速度。<br>&nbsp;<br>如果从动量守恒角度考虑，设原质量、速度为m和v，增加或减少的质量为dm，造成的速度增量为dv，相对分离速度为u，就有<script type="math/tex">(m+dm)(\bm{v}+d\bm{v})-dm·(v-u)=m\bm{v}</script>展开化简就得到<script type="math/tex">md\bm{v}=\bm{u}dm</script>对于火箭来说，因为燃料喷出dm小于0，而u视为恒定，且u和v都作用在一直线上，所以可以写成<script type="math/tex">mdv=-udm</script>，即<script type="math/tex">\int_{0}^{v}dv=-u\int_{m_0}^{m}\frac{dm}{m}</script>，得<script type="math/tex">v=-u{\rm{ln} }\frac{m}{m_0}</script>其中，m0代表火箭的燃料质量，这个公式叫齐奥科夫斯基公式，由俄罗斯火箭学家齐奥科夫斯基提出。<h3 id="2-5-能量守恒"><a href="#2-5-能量守恒" class="headerlink" title="2.5 能量守恒"></a>2.5 <strong>能量守恒</strong></h3>略<h3 id="2-6-功"><a href="#2-6-功" class="headerlink" title="2.6 功"></a>2.6 <strong>功</strong></h3></li>
<li>2.6.1 直角坐标系下的功<br><script type="math/tex">dA=\bm{F}·d\bm{r}\\=(F_x\bm{i}+F_y\bm{j}+F_z\bm{k})·d(x\bm{i}+y\bm{j}+z\bm{k})\\=F_xdx+F_ydy+F_zdz</script>积分即可</li>
<li>2.6.2 自然坐标系下的功<br>元位移可以近似用切线上一小段代替<script type="math/tex">{\rm{d} }\bm{r}={\rm{d} }s\bm{e_t}</script>然后将力分为法向和切向<script type="math/tex">{\rm{d} }A=\bm{F}·{\rm{d} }\bm{r}\\=(F_t\bm{e_t}+F_n\bm{e_n})·{\rm{d} }s\bm{e_t}=F_t{\rm{d} }s</script>所以法向力分量不做功（显而易见），于是功就是力的切向分量和弧坐标增量的乘积。</li>
<li>2.6.3 极坐标系下的功<br>略<h3 id="2-7-动能定理"><a href="#2-7-动能定理" class="headerlink" title="2.7 动能定理"></a>2.7 <strong>动能定理</strong></h3></li>
<li>2.7.1 <strong>质点动能定理</strong><br>从自然坐标系考察，我们已经得到<script type="math/tex">{\rm{d} }A=F_t{\rm{d} }s</script>利用牛顿第二定律，得到<script type="math/tex">{\rm{d} }A=m\frac{ {\rm{d} }v_t}{ {\rm{d} }t}{\rm{d} }s=m\frac{ {\rm{d} }s}{ {\rm{d} }t}{\rm{d} }v_t=mv_t{\rm{d} }v_t</script>两边积分，有<script type="math/tex">\Delta A=\frac{1}{2}mv^2-\frac{1}{2}mv_0^2</script>项$\frac{1}{2}mv^2$表示物体的运动状态，我们定义其为动能，用$E_k$表示。它的变化就是功。<br>所以质点的动能定理表述为合力对质点的功等于质点动能增加量，<script type="math/tex">{\rm d}A={\rm d}E_k,　　A=\Delta E_k</script></li>
<li>2.7.2 <strong>质点系动能定理</strong><br>对于每个质点都有动能定理成立，所以对它们求和得到<script type="math/tex">\sum A_i=\sum E_{ki}-\sum E_{k0i}</script>左边的功的和可以分为外力的功和内力的功（之所以动量定理不用考虑内力是由于动量和冲量为矢量，内力冲量可以相互抵消，而能量和共都是标量，所以相互作用力的功相互叠加）。所以有<script type="math/tex">\sum A_外+\sum A_内=\sum E_{k}-\sum E_{k0}</script>这就是质点系的动能定理，即<strong>质点系的动能增量在数值上等于一切外力所做的功与一切内力所做的功的代数和</strong>。<h3 id="2-8-势能"><a href="#2-8-势能" class="headerlink" title="2.8 势能"></a>2.8 <strong>势能</strong></h3><ul>
<li>2.8.1 <strong>力场</strong><br>如果一确定质点所受之力仅与质点位置有关，即<script type="math/tex">\bm{F}=\bm{F(\bm{r})}</script>那么这种力就是场力，发生这种力的空间称为力场。</li>
<li>2.8.2 <strong>保守力和非保守力</strong><br>在惯性系中，如果一个力<br>推导如下：<br>设有两个质点，且其间存在相互作用力$F$。对其中一个质点来说，<script type="math/tex">{\rm d}A=\bm{F}·{\rm d}\bm{r}</script>由于相互作用力只存在于质点连线上（不考虑磁场这类无源场），所以功可以化为<script type="math/tex">{\rm d}A=F_r{\rm d}r</script>这说明二质点间的作用力和反作用力的功的代数和决定于力和质点间的相对距离的变化。如果两个质点没有对心运动那就没有内力功。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-9-碰撞"><a href="#2-9-碰撞" class="headerlink" title="2.9 碰撞"></a>2.9 <strong>碰撞</strong></h3><ul>
<li>2.9.1 <strong>对心碰撞</strong><br>对心碰撞一定是一维的。<br>引入恢复系数（末速度之差除以初速度之差）<script type="math/tex">e=\frac{v_2-v_1}{v_{10}-v_{20} }　　(0<e<1)</script><br>把恢复系数代入到动量守恒式中，解得<script type="math/tex">v_1=v_{10}-\frac{(1+e)m_2(v_{10}-v_{20})}{m_1+m_2}$$$$v_2=v_{20}-\frac{(1+e)m_1(v_{20}-v_{10})}{m_1+m_2}</script>碰撞损失的能量为<script type="math/tex">E_损=\frac{1}{2}(1-e^2)\mu (v_{10}-v_{20})^2</script>其中$\mu$为折合质量$\frac{m_1m_2}{m_1+m_2}$</li>
<li><p>2.9.2 <strong>非对心碰撞</strong><br>非对心碰撞的作用力只在与碰撞面垂直的方向上对被动球有作用，因为在切向上，由于假设光滑，因而不存在摩擦力让被动球横向运动。故求解时应该把主动球的速度分成两个方向，切向的速度在完全弹性碰撞以后是没有损失的。在法向上，与正碰是一样的，恢复系数也取这个方向上的速度分量。<br>公式现推。</p>
<p>下面是几个特殊情况（m2静止）</p>
<ul>
<li><p>2.9.2.1 完全弹性碰撞 m1=m2<br>垂直碰撞面方向（法向）速度交换，切向没有变化。<br>此类碰撞的特性是不管碰撞后如何运动，两个小球的运动方向总是成直角。证明如下：<script type="math/tex">m\bm{v_1}+m\bm{v_2}=m\bm{v_{10} }$$$$\bm{v_1}+\bm{v_2}=\bm{v_{10} }</script>按矢量合成法则，v1、v2和v10三个矢量将围成一个三角形。再由能量守恒，<script type="math/tex">\frac{1}{2}mv_1^2+\frac{1}{2}mv_2^2=\frac{1}{2}mv_{10}^2</script>即得<script type="math/tex">v_1^2+v_2^2=v_{10}^2</script>按照勾股定理，该三角形是直角三角形，v1和v2垂直。</p>
</li>
<li><p>2.9.2.2 完全弹性碰撞 m1&lt;&lt;m2<br>此时m2保持静止，m1法向速度方向反向、大小不变，切向速度不变。</p>
<h3 id="2-10-质心参考系和柯尼希定理"><a href="#2-10-质心参考系和柯尼希定理" class="headerlink" title="2.10 质心参考系和柯尼希定理"></a>2.10 <strong>质心参考系和柯尼希定理</strong></h3><p>质心参考系就是相对于被研究质点系质心平动的参考系。质心参考系一般是非惯性系。<br>设某一质点相对于基本参考系的速度为$v_i$，相对于质心参考系的速度为$v_i’$，质心参考系相对于基本参考系的速度为$v_0$。那么质点系的动能为<script type="math/tex">E_k=\frac{1}{2}\sum m_i(\bm{v_0}+\bm{v_i'})^2=\frac{1}{2}\sum m_i(v_0^2+v_i'^2)+(\sum m_i\bm{v_i'})·\bm{v_0}</script>由于参考系相对质心平动，所以质点系的质心在质心参考系内是静止的，所以$\sum m_i\bm{r_i}=\bm{R}$，R是一定矢量。对这个式子求导，就得到<script type="math/tex">\sum m_i\bm{v_i}=0</script><strong>上式是质心参考系的一个重要性质</strong>。所以，动能简化为<script type="math/tex">E_k=\frac{1}{2}\sum m_i(v_0^2+v_i'^2)</script>设质点系总质量为$m$，则有<script type="math/tex">E_k=\frac{1}{2}mv_0^2+\sum (\frac{1}{2}m_iv_i'^2)</script>这就是柯尼希定理，它表明，<strong>质点系相对于某基本参考系的动能等于质心动能（假设所有质量集中于质心的动能）和各个质点相对于质心参考系的动能的和</strong>。<br>&nbsp;<br>利用柯尼希定理可以方便地求解二体问题。设两个质点m1和m2，它们构成了质点系，质点系相对基本参考系的速度为$\bm{v_0}$，$\bm{u}$表示m1相对m2的速度，两个质点相对于质心参考系的速度分别为$\bm{v_1’}$、$\bm{v’_2}$即<script type="math/tex">\bm{u}=\bm{v_1'}-\bm{v_2'}</script>即<script type="math/tex">m_1\bm{u}=m_1\bm{v_1'}-m_1\bm{v_2'}</script>对于质心参考系又有<script type="math/tex">m_1\bm{v_1'}+m_1\bm{v_1'}=0</script>联立得到<script type="math/tex">\bm{v_1'}=\frac{m_2\bm{u} }{m_1+m_2}$$$$\bm{v_2'}=-\frac{m_1\bm{u} }{m_1+m_2}</script>代入相对质心参考系的总动能$E_k’$，得到<script type="math/tex">E_k'=\frac{1}{2}\mu u^2$$$\mu$是折合质量。所以**对于一切二质点运动**，都有</script>E_k=\frac{1}{2}mv_0^2+\frac{1}{2}\mu u^2$$碰撞过程中，一般不计外力，所以质心的速度不变，因而上式第一项是不变的，那么碰撞损失能力主要体现在第二项。对于完全非弹性碰撞，第二项会变为0.在高能物理领域，原子撞击时我们追求大的相对速度，因而外力能提供的功一定的情况下，要上式第一项尽可能的小，也就是对撞的效果要好于动原子撞击静原子。</p>
<h2 id="3-角动量"><a href="#3-角动量" class="headerlink" title="3 角动量"></a>3 角动量</h2><h3 id="3-1-角动量定理"><a href="#3-1-角动量定理" class="headerlink" title="3.1 角动量定理"></a>3.1 角动量定理</h3><p>为了描述转动，引入角动量<script type="math/tex">\bm{L}=\bm{r}\times m\bm{v}=\bm{r}\times \bm{p}</script>对上式求导，<script type="math/tex">\frac{d\bm{L} }{dt}=\frac{d\bm{r} }{dt}\times \bm{p}+\bm{r}\times\frac{d\bm{p} }{dt}</script>又<script type="math/tex">\frac{d\bm{r} }{dt}\times \bm{p}=\bm{v}\times \bm{p}=0</script>所以<script type="math/tex">\frac{d\bm{L} }{dt}=\bm{r}\times\frac{d\bm{p} }{dt}=\bm{r}\times \bm{F}</script>而质点相对于参考点的的力矩<script type="math/tex">\bm{M}=\bm{r}\times \bm{F}</script>所以有<script type="math/tex">\bm{M}=\frac{d\bm{L} }{dt}</script>这就是<strong>角动量定理</strong>，即质点所受力相对于某参考点的力矩等于相对于该参考点的角动量的变化率。<br>对于力矩，如果有多个力，那么合力矩为<script type="math/tex">\bm{M}=\sum(\bm{r}\times\bm{F_i})=\bm{r}\times\bm{F_1}+\bm{r}\times\bm{F_2}+···+\bm{r}\times\bm{F_n}=\bm{r}\times\sum{\bm{F_i} }</script></p>
<h3 id="3-2-角动量守恒"><a href="#3-2-角动量守恒" class="headerlink" title="3.2 角动量守恒"></a>3.2 角动量守恒</h3><p>由<script type="math/tex">\bm{M}=\frac{d\bm{L} }{dt}</script>可知，<strong>如果外力矩$\bm{M}$为0，那么角动量$\bm{L}$就是一守恒量</strong>。这就是质点对参考点的角动量守恒定律。<br>角动量作为矢量，也可以分为三个方向，于是我们同样地有三个分量上角动量各自守恒。例如，<strong>如果外力矩$\bm{M_x}$为0，那么过程中$\bm{L_x}$为一守恒量</strong>。<br>需要注意的是，有时候改变参考点可以改变力矩的大小，也就是说角动量守恒依赖于参考点。</p>
<h3 id="3-3-质点对轴角动量及对轴角动量守恒"><a href="#3-3-质点对轴角动量及对轴角动量守恒" class="headerlink" title="3.3 质点对轴角动量及对轴角动量守恒"></a>3.3 质点对轴角动量及对轴角动量守恒</h3><p>由于参考点的任意性会对角动量产生不确定性，而转动的轴是唯一确定的，所以角动量对轴的分量的是确定的。取力矩和角动量在z轴的分量<script type="math/tex">M_z=\frac{dL_z}{dt}</script>把外力分为平行与转动平面和垂直于转动平面两个分量，对轴的力矩由于叉乘我们只需要考虑平行于转动平面的力的分量。同样的，位矢$\bm{r}$我们也只需要考虑平行于转动平面的分量，即<script type="math/tex">\bm{M_z}=\bm{r_1}\times\bm{F_1}</script>由于本来就在求轴上的分量，所以可以不关心方向，得到<script type="math/tex">M_z=r_1F_1sin\alpha</script>这里的技巧是，我们把$\alpha$定义成总是逆时针取的角度，也就是把$\bm{r_1}$和$\bm{F_1}$放在同一起点，然后从位矢分量开始，按逆时针的方向转到力的分量方向上转过的角度，这样可以保证正负性。或者更简单直观的方法是，上式只用于求力矩的绝对值，正负从力是促进还是阻碍质点转动来判断，促进取正，阻碍取负。<br>还有，上文的“轴”并非一定是转动轴，它可以是空间内任意一条直线。<br><strong>总之，力对轴上一点的力矩在轴上的投影就等于与力对轴的力矩</strong>。这与哪个参考点的选取没有关系，任意一个参考点都是一样的。<br>&nbsp;<br>那么对轴一样也有守恒律：<strong>如果外力对轴的力矩为0，质点对轴角动量不变</strong>。这才是我们常用的角动量守恒。</p>
<h3 id="3-4-质点系情况下的角动量和守恒律"><a href="#3-4-质点系情况下的角动量和守恒律" class="headerlink" title="3.4 质点系情况下的角动量和守恒律"></a>3.4 质点系情况下的角动量和守恒律</h3></li>
</ul>
</li>
<li>3.4.1 <strong>对参考点的角动量</strong><br>对于一个质点i，有<script type="math/tex">\bm{M_{i内} }+\bm{M_{i外} }=\frac{d\bm{L_i} }{dt}</script>求和有<script type="math/tex">\sum\bm{M_{i内} }+\sum\bm{M_{i外} }=\sum\frac{d\bm{L_i} }{dt}</script>显然<script type="math/tex">\sum\bm{M_{i内} }=0</script>，所以设质点系角动量为$\bm{L}$，就有<script type="math/tex">\sum\bm{M_{i外} }=\frac{d\bm{L} }{dt}</script>所以质点系对参考点的角动量守恒就是<strong>若外力对参考点的力矩为0，则质点系对该参考点的角动量守恒</strong>。</li>
<li>3.4.2 <strong>质点系对轴的角动量</strong><script type="math/tex; mode=display">\sum\bm{M'_{i外} }=\frac{d\bm{L'} }{dt}</script></li>
</ul>
<h2 id="4-天体运动"><a href="#4-天体运动" class="headerlink" title="4 天体运动"></a>4 天体运动</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weizihao">
      <meta itemprop="description" content="Freedom, Liberation, Persistence, Responsibility">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arcadia">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/16/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-16 21:18:18" itemprop="dateCreated datePublished" datetime="2023-06-16T21:18:18+08:00">2023-06-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weizihao</p>
  <div class="site-description" itemprop="description">Freedom, Liberation, Persistence, Responsibility</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weizihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/canvas_lines.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
